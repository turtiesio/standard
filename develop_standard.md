# 개발 스탠다드

[목차](#목차)

## 개발 철학

- **지속 가능한 개발**: 가장 느린 길이 가장 빠른 길이라 믿습니다.
- **효율적 커뮤니케이션**: 저문맥 커뮤니케이션을 지향하며, 비동기적 문서 기반 소통을 선호합니다.
- **실패로부터 배우기**: 실패를 두려워하지 않고, 실패를 통해 성장합니다.
- **데이터 기반 의사결정**: 정량적 데이터와 정성적 피드백을 기반으로 의사결정을 합니다.

## 기본 규칙

### 1. 버전 관리

- **Semantic Versioning(X.Y.Z)**
  - **X**(MAJOR): 호환성이 깨지는 변경사항
  - **Y**(MINOR): 호환성 유지하며 기능 추가
  - **Z**(PATCH): 호환성 유지하며 버그 수정

#### Git 브랜치 전략

- **`main` (또는 `master`)**: 배포 가능한 최신 버전. 모든 변경 사항은 이 브랜치에서 병합됩니다.
- **`feature/이름` (또는 `fix/이름`)**: 기능 개발 또는 버그 수정을 위한 브랜치. 각 기능 또는 버그 수정마다 하나씩 생성됩니다.

  - 브랜치 이름은 `feature/기능이름` 또는 `fix/버그이름` 형태로 작성합니다. (예: `feature/login-form`, `fix/user-profile-bug`)

- **GitHub Flow 적용**

  1. 새로운 기능 개발 또는 버그 수정이 필요하면 `main` 브랜치에서 새로운 기능 브랜치를 생성합니다.
  2. 기능 브랜치에서 작업을 수행하고, 주기적으로 커밋합니다.
  3. 작업이 완료되면, GitHub, GitLab, Bitbucket 등의 플랫폼에서 `main` 브랜치로 PR(Pull Request)을 생성합니다.
  4. 코드 리뷰를 받고, 수정 사항이 있다면 수정합니다.
  5. PR이 승인되면, `main` 브랜치로 병합합니다.
  6. `main` 브랜치가 배포되면, 기능 브랜치를 삭제합니다.

- **병합 전략**:

  - 모든 병합은 Pull Request (PR)을 통해 진행합니다.
  - 코드 리뷰 후 PR이 승인되면 `main` 브랜치로 병합합니다.
  - 병합 시 충돌이 발생하면, 코드 작성자가 직접 해결합니다. (일반적으로 리베이스 또는 스쿼시 병합을 권장)
  - 필요에 따라 병합 전략은 변경 가능하며, 팀 내에서 합의합니다.

#### 커밋 메시지 컨벤션

- **Conventional Commits v1.0.0**: [스펙 링크](https://www.conventionalcommits.org/en/v1.0.0/#commit-message-with--to-draw-attention-to-breaking-change)
  - 자동 CHANGELOG 생성, 버전 관리 자동화, 변경 사항 파악 용이, 커뮤니케이션 비용 절약.

##### Conventional Commits

- **기본 구조**:

  ```md
  <type>[optional scope]: <description>

      [optional body]
      [optional footer(s)]
  ```

- **타입**:
  - feat: 새로운 기능 추가 (MINOR 버전 증가)
  - fix: 버그 수정 (PATCH 버전 증가)
  - 기타: build, chore, ci, docs, style, refactor, perf, test 등
- **Breaking Change 표시**:
  - 타입 뒤에 `!` 추가: `feat!:`
  - 또는 푸터에 `BREAKING CHANGE:` 명시 (MAJOR 버전 증가)
- **스코프**: 선택사항이며, 변경 내용의 범위를 괄호로 표시: `feat(api):`, `fix(lang):`

### 2. API 관리

#### 문서화 도구

- REST API: OpenAPI 스펙 준수 (Swagger, ReDoc)
- gRPC: Protocol Buffers 활용
- GraphQL: GraphQL 스키마 정의
- 코드 자동 생성 및 문서화 도구 활용

#### 버전 체계

- 내부 API: `/api/i/v{n}` 형식
- 외부 API: `/api/p/v{n}` 형식
- Breaking Changes 자동화 테스트 구현
- Deprecated API 관리 정책 운영
- API Deprecation 정책 명확히 정의
  - Deprecation 기간 설정
  - 대체 API 제공

#### 추가 고려사항

- API 보안 정책 수립 필요 (인증, 인가)
- 성능 모니터링 체계 구축
- 에러 처리 표준화 (Error Code, Message Format)
- API 변경 추적 및 문서화

#### API Rate Limiting

- API 요청 제한 정책 수립
- 토큰 기반 rate limiting 구현
- 사용자별/IP별 제한 설정
- 과도한 요청 방지 및 서비스 보호
- Rate Limiting 정책 변경 기록

#### API 변경 관리

- API 변경 사항은 반드시 문서화하고 팀에 공유
- 하위 호환성을 유지할 수 없는 변경은 신중하게 결정
- API 변경 시 알림 시스템 구축

### 3. 문서화 체계

#### 핵심 문서 구성

- **기술 문서**: 아키텍처, 디자인 패턴, 코드 스타일, 기술 결정 기록(ADR)
- **운영 문서**: 배포, 모니터링, 장애 대응, 재해 복구 계획(DRP)
- **API 문서**: 인터페이스 명세, 예제, 테스트, 데이터 모델
- **프로젝트 문서**: 요구사항, 기획, 사용자 스토리, 와이어프레임
- **온보딩 문서**: 신규 팀원을 위한 가이드

#### 문서 관리

- 문서 버전 관리 (Git, Confluence, Notion)
- 접근성과 검색 용이성 확보
- 정기적인 문서 리뷰 및 업데이트
- 문서 템플릿 표준화
- 문서 작성 가이드라인 제공

### 4. 지속적 개선

#### 기술 부채 관리

- 정기적 기술 검토(Tech radar)
- 개선 우선순위 체계화
- 기술 로드맵 관리
- 기술 부채 기록 및 관리 (JIRA, Trello)
- 기술 부채 상환 계획

#### 지식 공유 문화

- 정기 기술 공유 세션 (스터디, 세미나)
- 문서화 플랫폼 운영
- 코드 리뷰 문화 정착
- 멘토링 시스템 구축
- 페어 프로그래밍 장려
- 컨퍼런스 및 교육 지원

## 프로젝트 및 기술 관리 가이드라인

### 프로젝트 관리

- **애자일 방법론**
  - 스크럼, 칸반 등 적합한 방법론 선택
  - 스프린트, 백로그 관리
  - 회고, 데일리 스크럼
- **커뮤니케이션 전략**
  - 원페이지 기획서 중심의 저문맥 커뮤니케이션
  - 상대방의 지식수준을 고려한 명확한 정보 전달
  - 효율적인 이슈 트래킹 시스템 구축
- **리소스 관리**
  - 프로젝트 이해관계자 맵핑
  - 일정 및 인력 리소스 최적화
  - 기획 등, 변경 관리 프로세스 수립

#### 스프린트 계획

- 스프린트 목표 설정
- 사용자 스토리 기반 작업 분배
- 데드라인 설정

#### 일일 스크럼

- 매일 짧게 진행 (15분)
- 어제 한 일, 오늘 할 일, 장애물 공유
- 빠른 문제 해결

### 기술 아키텍처

- **핵심 설계 원칙**
  - 확장성: 수평적/수직적 확장 고려
  - 견고성: SPOF 제거, 장애 허용 메커니즘
  - 성능: 캐싱 전략, DB 최적화, 부하 분산
  - 보안: 데이터 보호, 권한 관리

#### 마이크로서비스 아키텍처

- 서비스 분리 기준
- API Gateway 패턴
- 서비스 간 통신 방식
- 데이터 관리 전략

- **아키텍처 관리**
  - ADR(Architecture Decision Records) 문서화
  - Tech Radar를 통한 기술 동향 모니터링
  - 레거시 시스템 현대화 전략
  - 아키텍처 다이어그램 작성 및 유지보수

#### 아키텍처 패턴

- 레이어드 아키텍처, MVC, MVVM 등 패턴 적용
- 필요에 따라 CQRS, 이벤트 소싱 패턴 도입
- 패턴 적용 이유와 장단점 기록

- **기술 스택 선정 기준**
  - 벤더 락인 회피
  - 오픈소스 생태계 활성도
  - 성능/유지보수성 평가
  - 필요 기능 충족도
  - 팀 내 기술 숙련도 고려

### 인프라 구조

- **클라우드 서비스**
  - AWS, GCP, Azure 등 클라우드 플랫폼 선정
  - 클라우드 서비스 모델 선택 (IaaS, PaaS, SaaS)
  - 클라우드 리소스 관리 전략
  - 서비스 비용 분석 및 최적화
- **데이터 아키텍처**
  - 데이터 모델링 표준
  - 데이터 파이프라인 설계
  - 백업/복구 전략
  - 데이터 거버넌스 정책
- **장애 대응**
  - 서킷 브레이커 패턴 적용
  - 폴백 메커니즘 구현
  - 장애 복구 프로세스 정의
  - 재해 복구 계획(DRP)

#### 데이터베이스 관리

- **데이터베이스 설계**
  - 스키마 설계 표준
  - 인덱싱 전략
  - 정규화/비정규화 고려
  - 데이터베이스 선택 가이드라인
- **데이터베이스 운영**
  - 데이터베이스 모니터링
  - 백업 및 복구 정책
  - 성능 튜닝 전략
  - 데이터베이스 접근 권한 관리

## 코드 품질 관리 가이드라인

### 코딩 원칙

- **설계 원칙**
  - SOLID: 단일책임, 개방폐쇄, 리스코프 치환, 인터페이스 분리, 의존성 역전
  - KISS: Keep It Simple, Stupid
  - DRY: Don't Repeat Yourself
  - YAGNI: You Aren't Gonna Need It
  - 테스트 용이성 고려

#### 클린 코드

- 의미 있는 변수 및 함수 이름 사용
- 함수는 한 가지 일만 하도록 작성
- 코드 중복을 제거
- 가독성 높은 코드 작성

#### 코드 가독성

- 일관성 있는 코드 스타일 적용
- 적절한 주석 및 문서화
- 코드를 논리적인 그룹으로 구성
- 코드 줄 길이를 제한
- 명확한 네이밍

- **코드 스타일**
  - 자동화된 Linter/Formatter 설정
  - Cyclomatic Complexity 관리
  - 정적 분석 도구 활용 (SonarQube, ESLint, Pylint)
  - 언어별 정해진 코드 컨벤션 준수 (PEP8, Google Style)

### 코드 관리

- **브랜치 전략**
  - 메인 전략 (GitHub Flow)
  - Hotfix 프로세스
  - Cherry-pick 가이드라인
  - Release 관리 체계
  - 코드 소유권 정책
- **PR(Pull Request) 프로세스**
  - 표준화된 PR 템플릿
    - 우선순위 기술(긴급, 보통 - 데드라인) 등등..
    - 기획/스펙 문서 링크
    - 구현 계획 및 변경 내용
    - 테스트 케이스
    - 디자인 명세
  - 코드 리뷰 중점 사항
    - 리뷰 체크리스트 체크
    - 가독성/컨벤션 준수
    - 비즈니스 로직 검증
    - 성능 고려사항
    - 보안 취약점 검토

#### 코드 스타일

- 코드 스타일 가이드 정의 (예: Airbnb JavaScript Style Guide)
- 팀 전체 코드 스타일 통일
- 스타일 변경 사항은 문서화

#### 자동 코드 포맷터

- Prettier, Black 등 자동 포맷터 사용
- 코드 스타일 자동화
- 코드 스타일 일관성 유지

### 코드 리뷰

- **코드 리뷰 프로세스**
  - 코드 리뷰 가이드라인 정의
  - 코드 리뷰 템플릿 사용
  - 코드 리뷰어 지정
  - 코드 리뷰 결과 반영
  - 코드 리뷰 시간 준수(우선순위, 데드라인 등 준수)
  - 건설적인 피드백 문화

### 에러 처리

- **에러 관리 체계**
  - 로깅 레벨 정의 (Fatal/Error/Warn/Info/Debug)
  - 예외 처리 패턴 (try-catch, error boundary)
  - 유저에 디테일한 에러 표시 X(500: Internal server error)
  - 에러 로깅 및 알림 시스템
  - 에러 발생 시 사용자 친화적인 메시지 표시
- **의존성 관리**
  - 외부 라이브러리 버전 관리 (package.json, requirements.txt)
  - 보안 취약점 모니터링
  - 의존성 업데이트 정책 (정기 업데이트)
  - 사용하지 않는 의존성 제거

### 입력 데이터 검증

- **입력값 검증**
  - SQL Injection 방지 (파라미터화된 쿼리 사용)
  - XSS 방지 (데이터 이스케이핑)
  - 입력 길이 및 형식 검증
  - API 요청 데이터 스키마 검증
  - 서버 측 유효성 검사 (백엔드)
- **인증/인가**
  - 세션 관리 보안
  - 패스워드 해싱 (bcrypt 등 사용)
  - HTTPS 통신 필수
  - JWT 토큰 보안 관리
  - API 키 관리 정책
  - 역할 기반 접근 제어(RBAC)

### 서버 데이터 보호

- **민감 정보 처리**
  - 암호화 표준 준수 (AES, RSA)
  - API 키, 시크릿 보안 관리 (환경 변수, Vault)
  - 개인정보 마스킹 처리
  - 로그에 민감 정보 노출 방지
  - 데이터베이스 접근 권한 관리
- **접근 제어**
  - RBAC(Role-Based Access Control) 구현
  - 최소 권한 원칙 적용
  - API 엔드포인트 권한 검사
  - 리소스 접근 로깅
  - 감사 로깅 시스템

### 보안 취약점 방지

- **일반적인 취약점**
  - CSRF 방지 (CSRF 토큰)
  - 파일 업로드 보안 (파일 형식 검사, 업로드 경로 제한)
  - 디렉토리 순회 공격 방지
  - 세션 고정 공격 방지
  - 인증 우회 방지
  - 권한 상승 공격 방지
- **의존성 관리**
  - 보안 취약점 스캐닝 (OWASP Dependency-Check)
  - 패키지 버전 관리
  - 정기적인 보안 업데이트
  - 컨테이너 이미지 취약점 점검 (Docker Scan)
  - 정적 코드 분석 도구 활용

<!--  -->
<!--  -->
<!--  -->

## QA 및 품질 관리 가이드라인

### 기술 부채 관리 메트릭

- **핵심 측정 지표**
  - 코드 복잡도 (Cyclomatic Complexity)
  - 중복 코드 비율
  - 테스트 커버리지
  - 레거시 코드 비율
  - 미해결 이슈 수와 경과 시간
  - 코드 품질 지표 (SonarQube)
- **모니터링 전략**
  - 정기적인 메트릭 리포트
  - 임계치 기반 알림 시스템
  - 개선 우선순위 결정 기준
  - 기술 부채 관리 프로세스

### 테스트 자동화 전략

- **테스트 계층**
  - 단위 테스트: 개별 컴포넌트 검증
  - 통합 테스트: 컴포넌트 간 상호작용
  - E2E 테스트: 전체 시스템 흐름
  - 회귀 테스트: 기존 기능 영향도
  - API 테스트: API 엔드포인트 검증
  - UI 테스트: 사용자 인터페이스 검증
- **자동화 구현**
  - CI/CD 파이프라인 통합
  - 테스트 데이터 관리
  - 테스트 환경 구성
  - 커버리지 목표 설정
  - 자동화 테스트 결과 리포트

#### 테스트 코드 작성 규칙

- 각 테스트는 독립적으로 작성
- AAA 패턴(Arrange-Act-Assert) 준수
- 테스트 코드에 주석 작성
- 테스트 코드도 코드 리뷰 대상
- 테스트 코드 유지보수

### 성능 최적화 기준

- **성능 지표**
  - 응답 시간: P95, P99 기준
  - 처리량: RPS/TPS 목표
  - 리소스 사용량: CPU, 메모리, 디스크
  - 네트워크 지연: 백엔드/프론트엔드 통신
  - API 응답 시간, 페이지 로딩 시간
- **최적화 전략**
  - 로드 테스트 기준
  - 캐싱 전략 (Redis, Memcached)
  - 데이터베이스 쿼리 최적화
  - 프론트엔드 성능 최적화 (압축, Lazy Loading)
  - 코드 프로파일링

### 품질 보증 프로세스

- **QA 프로세스**
  - 테스트 계획 수립
  - 테스트 케이스 관리
  - 결함 추적 및 관리 (JIRA, Trello)
  - 릴리즈 승인 기준
  - 사용자 스토리 기반 테스트
- **성능 모니터링**
  - 실시간 모니터링 체계
  - 성능 벤치마크 도구 (JMeter, LoadRunner)
  - 주기적 성능 테스트
  - 병목 구간 식별
  - 성능 테스트 결과 리포트

<!--  -->
<!--  -->
<!--  -->

## DevOps 가이드라인

### 컨테이너화 및 인프라

- **컨테이너 관리**
  - Docker 이미지 최적화
  - 멀티 스테이지 빌드 전략
  - 컨테이너 보안 정책
  - 컨테이너 오케스트레이션 (Kubernetes, Docker Swarm)
- **인프라 자동화**
  - Infrastructure as Code (IaC) 구현 (Terraform, CloudFormation)
  - 환경 구성 자동화 (Ansible, Chef, Puppet)
  - 클라우드 리소스 관리
  - 프로비저닝 자동화

### CI/CD 파이프라인

- **배포 자동화**
  - 배포 전략 선택 (Blue-Green/Canary/Rolling)
  - 파이프라인 구성 (빌드, 테스트, 배포)
  - 자동화된 테스트 통합
  - 롤백 자동화
- **릴리스 관리**
  - 버전 관리 정책
  - 롤백 전략
  - 배포 스케줄링
  - 배포 후 검증 프로세스

#### CI/CD 도구

- Jenkins, GitLab CI, GitHub Actions, CircleCI 등 활용
- 파이프라인 구성 및 자동화
- 배포 환경 자동화

### 모니터링 및 알림

- **시스템 모니터링**
  - 로그 수집/분석 (ELK Stack, Grafana Loki)
  - 시스템 메트릭 추적 (Prometheus, Grafana)
  - 성능 지표 모니터링
  - 서비스 상태 모니터링 (Health Check)
- **알림 체계**
  - 심각도별 알림 채널 (SMS/전화/메신저)
  - 에스컬레이션 정책
  - 알림 임계값 설정
  - 알림 통합 관리 시스템 (PagerDuty)

### 장애 관리

- **예방적 조치**
  - 카오스 엔지니어링 실행 (Chaos Monkey)
  - 스트레스 테스트 수행
  - 성능 테스트 자동화
  - 사전 모니터링 및 알림
- **장애 대응**
  - 재해 복구 계획 (DRP)
  - 장애 복구 프로세스
  - 사후 분석 (Post-mortem)
  - 장애 발생 시 신속한 대응 및 복구

### 비용 최적화

- **리소스 관리**
  - 클라우드 비용 모니터링 (AWS Cost Explorer, GCP Billing)
  - 리소스 사용량 최적화
  - 비용 예측 및 계획
  - 리소스 자동 스케일링
  - 사용하지 않는 리소스 정리

## 보안 및 규정

### 인프라 보안

- 환경별 접근 권한 관리
- 중요 환경 격리 정책 (VPC, Subnet)
- 보안 감사 로깅
- 침입 탐지 시스템 (IDS) 및 침입 방지 시스템 (IPS) 도입
- 정기적인 보안 취약점 스캔
- 방화벽 설정 및 관리

### 데이터 보호

- 개인정보 처리 기준 (개인정보보호법)
- 데이터 암호화 정책 (데이터 전송, 저장)
- 접근 권한 관리 체계 (IAM)
- 데이터 유출 방지 (DLP) 정책
- 데이터 보존 정책 (백업 및 복구)
- 데이터 삭제 정책 (개인정보 파기)

### 컴플라이언스

- 규제 준수 체크리스트
- 정기적 보안 감사
- 보안 사고 대응 절차
- 개인정보보호법 준수
- 산업별 규제 준수 (예: HIPAA, GDPR, PCI DSS)
- 법률 자문 및 준수 프로세스

## 사용자 경험 설계

### 디자인 시스템

- 컴포넌트 라이브러리 (Storybook)
- 스타일 가이드 (색상, 타이포그래피)
- 상호작용 패턴
- UI Kit 및 디자인 에셋 제공 (Figma, Adobe XD)
- 디자인 시스템 문서화 (Design Tokens)
- 디자인 시스템 유지보수

### 접근성 표준

- WCAG 가이드라인 준수
- 다국어 지원
- 디바이스 호환성
- 스크린 리더 지원
- 키보드 탐색 지원
- 접근성 테스트 (웹 접근성 도구)

### UX 원칙

- 사용자 피드백 수집 (설문조사, 인터뷰)
- 사용성 테스트 (A/B 테스트, 사용자 테스트)
- 성능 최적화
- 사용자 중심 디자인
- 정보 구조 설계
- 사용자 여정 맵핑

#### 사용자 리서치

- 사용자 인터뷰 및 설문조사
- 사용자 행동 분석
- 페르소나 정의
- 사용자 피드백을 디자인에 반영

## 팀 역량 강화

### 온보딩 프로세스

- 단계별 교육 계획
- 필수 기술 스택 가이드
- 코드베이스 이해 지원
- 온보딩 체크리스트 제공
- 멘토 배정
- 온보딩 문서 제공
- 온보딩 기간 동안 피드백 제공

### 지속적 성장

- 기술 로드맵 제공
- 멘토링 시스템 운영
- 정기 기술 공유
- 컨퍼런스 및 교육 지원
- 개인별 성장 목표 설정
- 개인 학습 및 개발 시간 지원

### 팀 회고

- 각 스프린트 종료 후 회고 진행
- 잘된 점, 개선할 점 논의
- 개선 사항 실천 계획 수립
- 팀 협업 개선 노력
- 팀 생산성 향상 노력

## 목차

목차가 너무 기네요.. 아래로 내렸습니다.

- [개발 철학](#개발-철학)
- [기본 규칙](#기본-규칙)
  - [1. 버전 관리](#1-버전-관리)
    - [Git 브랜치 전략](#git-브랜치-전략)
    - [커밋 메시지 컨벤션](#커밋-메시지-컨벤션)
      - [Conventional Commits](#conventional-commits)
  - [2. API 관리](#2-api-관리)
    - [문서화 도구](#문서화-도구)
    - [버전 체계](#버전-체계)
    - [추가 고려사항](#추가-고려사항)
    - [API Rate Limiting](#api-rate-limiting)
    - [API 변경 관리](#api-변경-관리)
  - [3. 문서화 체계](#3-문서화-체계)
    - [핵심 문서 구성](#핵심-문서-구성)
    - [문서 관리](#문서-관리)
  - [4. 지속적 개선](#4-지속적-개선)
    - [기술 부채 관리](#기술-부채-관리)
    - [지식 공유 문화](#지식-공유-문화)
- [프로젝트 및 기술 관리 가이드라인](#프로젝트-및-기술-관리-가이드라인)
  - [프로젝트 관리](#프로젝트-관리)
    - [스프린트 계획](#스프린트-계획)
    - [일일 스크럼](#일일-스크럼)
  - [기술 아키텍처](#기술-아키텍처)
    - [마이크로서비스 아키텍처](#마이크로서비스-아키텍처)
    - [아키텍처 패턴](#아키텍처-패턴)
  - [인프라 구조](#인프라-구조)
    - [데이터베이스 관리](#데이터베이스-관리)
- [코드 품질 관리 가이드라인](#코드-품질-관리-가이드라인)
  - [코딩 원칙](#코딩-원칙)
    - [클린 코드](#클린-코드)
    - [코드 가독성](#코드-가독성)
  - [코드 관리](#코드-관리)
    - [코드 스타일](#코드-스타일)
    - [자동 코드 포맷터](#자동-코드-포맷터)
  - [코드 리뷰](#코드-리뷰)
  - [에러 처리](#에러-처리)
  - [입력 데이터 검증](#입력-데이터-검증)
  - [서버 데이터 보호](#서버-데이터-보호)
  - [보안 취약점 방지](#보안-취약점-방지)
- [QA 및 품질 관리 가이드라인](#qa-및-품질-관리-가이드라인)
  - [기술 부채 관리 메트릭](#기술-부채-관리-메트릭)
  - [테스트 자동화 전략](#테스트-자동화-전략)
    - [테스트 코드 작성 규칙](#테스트-코드-작성-규칙)
  - [성능 최적화 기준](#성능-최적화-기준)
  - [품질 보증 프로세스](#품질-보증-프로세스)
- [DevOps 가이드라인](#devops-가이드라인)
  - [컨테이너화 및 인프라](#컨테이너화-및-인프라)
  - [CI/CD 파이프라인](#cicd-파이프라인)
    - [CI/CD 도구](#cicd-도구)
  - [모니터링 및 알림](#모니터링-및-알림)
  - [장애 관리](#장애-관리)
  - [비용 최적화](#비용-최적화)
- [보안 및 규정](#보안-및-규정)
  - [인프라 보안](#인프라-보안)
  - [데이터 보호](#데이터-보호)
  - [컴플라이언스](#컴플라이언스)
- [사용자 경험 설계](#사용자-경험-설계)
  - [디자인 시스템](#디자인-시스템)
  - [접근성 표준](#접근성-표준)
  - [UX 원칙](#ux-원칙)
    - [사용자 리서치](#사용자-리서치)
- [팀 역량 강화](#팀-역량-강화)
  - [온보딩 프로세스](#온보딩-프로세스)
  - [지속적 성장](#지속적-성장)
  - [팀 회고](#팀-회고)
- [목차](#목차)
